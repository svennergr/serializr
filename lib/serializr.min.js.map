{"version":3,"file":"serializr.min.js","sources":["../src/utils/invariant.js","../src/utils/utils.js","../src/api/getDefaultModelSchema.js","../src/api/setDefaultModelSchema.js","../src/api/createModelSchema.js","../src/types/primitive.js","../src/constants.js","../src/api/serializable.js","../src/core/serialize.js","../src/core/Context.js","../src/core/deserialize.js","../src/types/object.js","../src/types/reference.js","../src/types/list.js","../src/api/createSimpleSchema.js","../src/core/cancelDeserialize.js","../src/core/update.js","../src/types/identifier.js","../src/types/date.js","../src/types/alias.js","../src/types/custom.js","../src/types/map.js","../src/types/mapAsArray.js","../src/types/raw.js"],"sourcesContent":["var formatters = {\r\n    j: function json(v) {\r\n        try {\r\n            return JSON.stringify(v)\r\n        } catch (error) {\r\n            return \"[UnexpectedJSONParseError]: \" + error.message\r\n        }\r\n    }\r\n}\r\n\r\nexport default function invariant(condition, message) {\r\n    if (!condition) {\r\n        var variables = Array.prototype.slice.call(arguments, 2)\r\n        var variablesToLog = []\r\n\r\n        var index = 0\r\n        var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\r\n            if (match === \"%%\") return match\r\n\r\n            var formatter = formatters[format]\r\n\r\n            if (typeof formatter === \"function\") {\r\n                var variable = variables[index++]\r\n\r\n                variablesToLog.push(variable)\r\n\r\n                return formatter(variable)\r\n            }\r\n\r\n            return match\r\n        })\r\n\r\n        if (console && variablesToLog.length > 0) {\r\n            // eslint-disable-next-line no-console\r\n            console.log.apply(console, variablesToLog)\r\n        }\r\n\r\n        throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"))\r\n    }\r\n}\r\n","import invariant from \"./invariant\"\r\n\r\nexport function GUARDED_NOOP(err) {\r\n    if (err) // unguarded error...\r\n        throw new Error(err)\r\n}\r\n\r\nexport function once(fn) {\r\n    var fired = false\r\n    return function () {\r\n        if (!fired) {\r\n            fired = true\r\n            return fn.apply(null, arguments)\r\n        }\r\n        invariant(false, \"callback was invoked twice\")\r\n    }\r\n}\r\n\r\nexport function parallel(ar, processor, cb) {\r\n    // TODO: limit parallelization?\r\n    if (ar.length === 0)\r\n        return void cb(null, [])\r\n    var left = ar.filter(function(){ return true }).length // only count items processed by forEach\r\n    var resultArray = []\r\n    var failed = false\r\n    var processorCb = function (idx, err, result) {\r\n        if (err) {\r\n            if (!failed) {\r\n                failed = true\r\n                cb(err)\r\n            }\r\n        } else {\r\n            resultArray[idx] = result\r\n            if (--left === 0)\r\n                cb(null, resultArray)\r\n        }\r\n    }\r\n    ar.forEach(function (value, idx) {\r\n        processor(value, processorCb.bind(null, idx), idx)\r\n    })\r\n}\r\n\r\nexport function isPrimitive(value) {\r\n    if (value === null)\r\n        return true\r\n    return typeof value !== \"object\" && typeof value !== \"function\"\r\n}\r\n\r\nexport function isModelSchema(thing) {\r\n    return thing && thing.factory && thing.props\r\n}\r\n\r\nexport function isPropSchema(thing) {\r\n    return thing && thing.serializer && thing.deserializer\r\n}\r\n\r\nexport function isAliasedPropSchema(propSchema) {\r\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\r\n}\r\n\r\nexport function isIdentifierPropSchema(propSchema) {\r\n    return typeof propSchema === \"object\" && propSchema.identifier === true\r\n}\r\n\r\nexport function isAssignableTo(actualType, expectedType) {\r\n    while (actualType) {\r\n        if (actualType === expectedType)\r\n            return true\r\n        actualType = actualType.extends\r\n    }\r\n    return false\r\n}\r\n\r\nexport function isMapLike(thing) {\r\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\r\n}\r\n\r\nexport function getIdentifierProp(modelSchema) {\r\n    invariant(isModelSchema(modelSchema))\r\n    // optimization: cache this lookup\r\n    while (modelSchema) {\r\n        for (var propName in modelSchema.props)\r\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\r\n                return propName\r\n        modelSchema = modelSchema.extends\r\n    }\r\n    return null\r\n}\r\n\r\nexport function processAdditionalPropArgs(propSchema, additionalArgs) {\r\n    if (additionalArgs) {\r\n        invariant(isPropSchema(propSchema), \"expected a propSchema\")\r\n        var argNames = [\"beforeDeserialize\", \"afterDeserialize\"]\r\n        argNames.forEach(function(argName) {\r\n            if (typeof additionalArgs[argName] === \"function\") {\r\n                propSchema[argName] = additionalArgs[argName]\r\n            }\r\n        })\r\n    }\r\n    return propSchema\r\n}\r\n\r\nexport { invariant }\r\n","import { isModelSchema } from \"../utils/utils\"\r\n\r\n/**\r\n * Returns the standard model schema associated with a class / constructor function\r\n *\r\n * @param {object} thing\r\n * @returns {ModelSchema} model schema\r\n */\r\nexport default function getDefaultModelSchema(thing) {\r\n    if (!thing)\r\n        return null\r\n    if (isModelSchema(thing))\r\n        return thing\r\n    if (isModelSchema(thing.serializeInfo))\r\n        return thing.serializeInfo\r\n    if (thing.constructor && thing.constructor.serializeInfo)\r\n        return thing.constructor.serializeInfo\r\n}\r\n","import { invariant, isModelSchema } from \"../utils/utils\"\r\n\r\n/**\r\n * Sets the default model schema for class / constructor function.\r\n * Everywhere where a model schema is required as argument, this class / constructor function\r\n * can be passed in as well (for example when using `object` or `ref`.\r\n *\r\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\r\n * as first argument anymore, because the default schema will be inferred from the instance type.\r\n *\r\n * @param {constructor|class} clazz class or constructor function\r\n * @param {ModelSchema} modelSchema - a model schema\r\n * @returns {ModelSchema} model schema\r\n */\r\nexport default function setDefaultModelSchema(clazz, modelSchema) {\r\n    invariant(isModelSchema(modelSchema))\r\n    return clazz.serializeInfo = modelSchema\r\n}\r\n","import { invariant } from \"../utils/utils\"\r\nimport getDefaultModelSchema from \"./getDefaultModelSchema\"\r\nimport setDefaultModelSchema from \"./setDefaultModelSchema\"\r\n\r\n/**\r\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\r\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\r\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\r\n *\r\n * @example\r\n * function Todo(title, done) {\r\n *     this.title = title;\r\n *     this.done = done;\r\n * }\r\n *\r\n * createModelSchema(Todo, {\r\n *     title: true,\r\n *     done: true,\r\n * });\r\n *\r\n * var json = serialize(new Todo('Test', false));\r\n * var todo = deserialize(Todo, json);\r\n *\r\n * @param {constructor|class} clazz class or constructor function\r\n * @param {object} props property mapping\r\n * @param {function} factory optional custom factory. Receives context as first arg\r\n * @returns {object} model schema\r\n */\r\nexport default function createModelSchema(clazz, props, factory) {\r\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\r\n    invariant(typeof clazz === \"function\", \"expected constructor function\")\r\n    var model = {\r\n        targetClass: clazz,\r\n        factory: factory || function() {\r\n            return new clazz()\r\n        },\r\n        props: props\r\n    }\r\n    // find super model\r\n    if (clazz.prototype.constructor !== Object) {\r\n        var s = getDefaultModelSchema(clazz.prototype.constructor)\r\n        if (s && s.targetClass !== clazz)\r\n            model.extends = s\r\n    }\r\n    setDefaultModelSchema(clazz, model)\r\n    return model\r\n}\r\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\r\nimport { isPrimitive } from \"../utils/utils\"\r\n\r\n/**\r\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\r\n *\r\n * @example\r\n * createModelSchema(Todo, {\r\n *     title: primitive(),\r\n * });\r\n *\r\n * console.dir(serialize(new Todo('test')));\r\n * // outputs: { title : \"test\" }\r\n *\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {ModelSchema}\r\n */\r\nexport default function primitive(additionalArgs) {\r\n    var result = {\r\n        serializer: function (value) {\r\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value)\r\n            return value\r\n        },\r\n        deserializer: function (jsonValue, done) {\r\n            if (!isPrimitive(jsonValue))\r\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\r\n            return void done(null, jsonValue)\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import primitive from \"./types/primitive\"\r\n\r\n/**\r\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\r\n *\r\n * @example\r\n * var schema = _.createSimpleSchema({\r\n *     a: _.custom(\r\n *         function(v) {\r\n *             return _.SKIP\r\n *         },\r\n *         function(v) {\r\n *             return v;\r\n *         }\r\n *     ),\r\n * });\r\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\r\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\r\n */\r\nexport var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\r\n\r\nexport var _defaultPrimitiveProp = primitive()\r\n","import { invariant, isPropSchema } from \"../utils/utils\"\r\nimport { _defaultPrimitiveProp } from \"../constants\"\r\nimport primitive from \"../types/primitive\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\nimport createModelSchema from \"../api/createModelSchema\"\r\n\r\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\r\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\r\nvar ARGUMENT_NAMES = /([^\\s,]+)/g\r\n\r\nfunction getParamNames(func) {\r\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\r\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\r\n    if(result === null)\r\n        result = []\r\n    return result\r\n}\r\n\r\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\r\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\r\n    // Fix for @serializable used in class constructor params (typescript)\r\n    var factory\r\n    if (propName === undefined && typeof target === \"function\"\r\n        && target.prototype\r\n        && descriptor !== undefined && typeof descriptor === \"number\") {\r\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\r\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\r\n        var paramNames = getParamNames(target)\r\n        if (paramNames.length >= descriptor) {\r\n            propName = paramNames[descriptor]\r\n            propSchema.paramNumber = descriptor\r\n            descriptor = undefined\r\n            target = target.prototype\r\n            // Create a factory so the constructor is called properly\r\n            factory = function(context) {\r\n                var params = []\r\n                for (var i = 0; i < target.constructor.length; i++) {\r\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\r\n                        var prop = context.modelSchema.props[key]\r\n                        if (prop.paramNumber === i) {\r\n                            params[i] = context.json[prop.jsonname]\r\n                        }\r\n                    })\r\n                }\r\n\r\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\r\n            }\r\n        }\r\n    }\r\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\r\n    var info = getDefaultModelSchema(target)\r\n\r\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\r\n        info = createModelSchema(target.constructor, {}, factory)\r\n    if (info && info.targetClass !== target.constructor)\r\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\r\n        info = createModelSchema(target.constructor, {}, factory)\r\n    info.props[propName] = propSchema\r\n    // MWE: why won't babel work without?\r\n    if (descriptor && !descriptor.get && !descriptor.set)\r\n        descriptor.writable = true\r\n    return descriptor\r\n}\r\n\r\n/**\r\n * Decorator that defines a new property mapping on the default model schema for the class\r\n * it is used in.\r\n *\r\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\r\n * The default factory will then invoke the constructor with the correct arguments as well.\r\n *\r\n * @example\r\n * class Todo {\r\n *     @serializable(primitive())\r\n *     title; // shorthand for primitves\r\n *\r\n *     @serializable done;\r\n *\r\n *     constructor(title, done) {\r\n *         this.title = title;\r\n *         this.done = done;\r\n *     }\r\n * }\r\n *\r\n * var json = serialize(new Todo('Test', false));\r\n * var todo = deserialize(Todo, json);\r\n *\r\n * @param arg1\r\n * @param arg2\r\n * @param arg3\r\n * @returns {PropertyDescriptor}\r\n */\r\nexport default function serializable(arg1, arg2, arg3) {\r\n    if (arguments.length === 1) {\r\n        // decorated with propSchema\r\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\r\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\r\n        return serializableDecorator.bind(null, propSchema)\r\n    } else {\r\n        // decorated without arguments, treat as primitive\r\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\r\n    }\r\n}\r\n","import { invariant, isPrimitive } from \"../utils/utils\"\r\nimport createModelSchema from \"../api/createModelSchema\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\nimport setDefaultModelSchema from \"../api/setDefaultModelSchema\"\r\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\r\n\r\n/**\r\n * Serializes an object (graph) into json using the provided model schema.\r\n * The model schema can be omitted if the object type has a default model schema associated with it.\r\n * If a list of objects is provided, they should have an uniform type.\r\n *\r\n * @param arg1 modelschema to use. Optional\r\n * @param arg2 object(s) to serialize\r\n * @returns {object} serialized representation of the object\r\n */\r\nexport default function serialize(arg1, arg2) {\r\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\r\n    var thing = arguments.length === 1 ? arg1 : arg2\r\n    var schema = arguments.length === 1 ? null : arg1\r\n    if (Array.isArray(thing)) {\r\n        if (thing.length === 0)\r\n            return [] // don't bother finding a schema\r\n        else if (!schema)\r\n            schema = getDefaultModelSchema(thing[0])\r\n    } else if (!schema) {\r\n        schema = getDefaultModelSchema(thing)\r\n    }\r\n    invariant(!!schema, \"Failed to find default schema for \" + arg1)\r\n    if (Array.isArray(thing))\r\n        return thing.map(function (item) {\r\n            return serializeWithSchema(schema, item)\r\n        })\r\n    return serializeWithSchema(schema, thing)\r\n}\r\n\r\nexport function serializeWithSchema(schema, obj) {\r\n    invariant(schema && typeof schema === \"object\", \"Expected schema\")\r\n    invariant(obj && typeof obj === \"object\", \"Expected object\")\r\n    var res\r\n    if (schema.extends)\r\n        res = serializeWithSchema(schema.extends, obj)\r\n    else {\r\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\r\n        res = {}\r\n    }\r\n    Object.keys(schema.props).forEach(function (key) {\r\n        var propDef = schema.props[key]\r\n        if (key === \"*\") {\r\n            invariant(propDef === true, \"prop schema '*' can only be used with 'true'\")\r\n            serializeStarProps(schema, obj, res)\r\n            return\r\n        }\r\n        if (propDef === true)\r\n            propDef = _defaultPrimitiveProp\r\n        if (propDef === false)\r\n            return\r\n        var jsonValue = propDef.serializer(obj[key], key, obj)\r\n        if (jsonValue === SKIP){\r\n            return\r\n        }\r\n        res[propDef.jsonname || key] = jsonValue\r\n    })\r\n    return res\r\n}\r\n\r\nexport function serializeStarProps(schema, obj, target) {\r\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\r\n        var value = obj[key]\r\n        // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\r\n        if (isPrimitive(value))\r\n            target[key] = value\r\n    }\r\n}\r\n\r\n/**\r\n * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\r\n *\r\n * @example\r\n * @serializeAll class Store {\r\n *     a = 3;\r\n *     b;\r\n * }\r\n *\r\n * const store = new Store();\r\n * store.c = 5;\r\n * store.d = {};\r\n * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5 });\r\n */\r\nexport function serializeAll(target) {\r\n    invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\")\r\n\r\n    var info = getDefaultModelSchema(target)\r\n    if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\r\n        info = createModelSchema(target, {})\r\n        setDefaultModelSchema(target, info)\r\n    }\r\n\r\n    getDefaultModelSchema(target).props[\"*\"] = true\r\n    return target\r\n}\r\n","import { GUARDED_NOOP, once, invariant, isAssignableTo } from \"../utils/utils\"\r\n\r\nvar rootContextCache = new WeakMap()\r\n\r\nexport default function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\r\n    this.parentContext = parentContext\r\n    this.isRoot = !parentContext\r\n    this.pendingCallbacks = 0\r\n    this.pendingRefsCount = 0\r\n    this.onReadyCb = onReadyCb || GUARDED_NOOP\r\n    this.json = json\r\n    this.target = null // always set this property using setTarget\r\n    this.hasError = false\r\n    this.modelSchema = modelSchema\r\n    if (this.isRoot) {\r\n        this.rootContext = this\r\n        this.args = customArgs\r\n        this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\r\n        this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\r\n    } else {\r\n        this.rootContext = parentContext.rootContext\r\n        this.args = parentContext.args\r\n    }\r\n}\r\n\r\nContext.prototype.createCallback = function (fn) {\r\n    this.pendingCallbacks++\r\n    // once: defend against user-land calling 'done' twice\r\n    return once(function (err, value) {\r\n        if (err) {\r\n            if (!this.hasError) {\r\n                this.hasError = true\r\n                this.onReadyCb(err)\r\n                rootContextCache.delete(this)\r\n            }\r\n        } else if (!this.hasError) {\r\n            fn(value)\r\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\r\n                if (this.pendingRefsCount > 0) {\r\n                    // all pending callbacks are pending reference resolvers. not good.\r\n                    this.onReadyCb(new Error(\r\n                        \"Unresolvable references in json: \\\"\" +\r\n                        Object.keys(this.pendingRefs).filter(function (uuid) {\r\n                            return this.pendingRefs[uuid].length > 0\r\n                        }, this).join(\"\\\", \\\"\") +\r\n                        \"\\\"\"\r\n                    ))\r\n                    rootContextCache.delete(this)\r\n                } else {\r\n                    this.onReadyCb(null, this.target)\r\n                    rootContextCache.delete(this)\r\n                }\r\n            }\r\n        }\r\n    }.bind(this))\r\n}\r\n\r\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\r\n// resolve immediately if possible\r\nContext.prototype.await = function (modelSchema, uuid, callback) {\r\n    invariant(this.isRoot)\r\n    if (uuid in this.resolvedRefs) {\r\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\r\n            return isAssignableTo(resolved.modelSchema, modelSchema)\r\n        })[0]\r\n        if (match)\r\n            return void callback(null, match.value)\r\n    }\r\n    this.pendingRefsCount++\r\n    if (!this.pendingRefs[uuid])\r\n        this.pendingRefs[uuid] = []\r\n    this.pendingRefs[uuid].push({\r\n        modelSchema: modelSchema,\r\n        uuid: uuid,\r\n        callback: callback\r\n    })\r\n}\r\n\r\n// given a model schema, uuid and value, resolve all references that where looking for this object\r\nContext.prototype.resolve = function (modelSchema, uuid, value) {\r\n    invariant(this.isRoot)\r\n    if (!this.resolvedRefs[uuid])\r\n        this.resolvedRefs[uuid] = []\r\n    this.resolvedRefs[uuid].push({\r\n        modelSchema: modelSchema, value: value\r\n    })\r\n    if (uuid in this.pendingRefs) {\r\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\r\n            var opts = this.pendingRefs[uuid][i]\r\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\r\n                this.pendingRefs[uuid].splice(i, 1)\r\n                this.pendingRefsCount--\r\n                opts.callback(null, value)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// set target and update root context cache\r\nContext.prototype.setTarget = function (target) {\r\n    if (this.isRoot && this.target) {\r\n        rootContextCache.delete(this.target)\r\n    }\r\n    this.target = target\r\n    rootContextCache.set(this.target, this)\r\n}\r\n\r\n// call all remaining reference lookup callbacks indicating an error during ref resolution\r\nContext.prototype.cancelAwaits = function () {\r\n    invariant(this.isRoot)\r\n    var self = this\r\n    Object.keys(this.pendingRefs).forEach(function (uuid) {\r\n        self.pendingRefs[uuid].forEach(function (refOpts) {\r\n            self.pendingRefsCount--\r\n            refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid))\r\n        })\r\n    })\r\n    this.pendingRefs = {}\r\n    this.pendingRefsCount = 0\r\n}\r\n\r\nexport function getTargetContext(target) {\r\n    return rootContextCache.get(target)\r\n}\r\n","/*\r\n * Deserialization\r\n */\r\nimport { invariant, isPrimitive, isModelSchema, parallel, GUARDED_NOOP } from \"../utils/utils\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\r\nimport Context from \"./Context\"\r\n\r\nfunction schemaHasAlias(schema, name) {\r\n    for (var key in schema.props)\r\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\r\n            return true\r\n    return false\r\n}\r\n\r\nfunction deserializeStarProps(schema, obj, json) {\r\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\r\n        var value = json[key]\r\n        // when deserializing we don't want to silently ignore 'unparseable data' to avoid\r\n        // confusing bugs\r\n        invariant(isPrimitive(value),\r\n            \"encountered non primitive value while deserializing '*' properties in property '\" +\r\n            key + \"': \" + value)\r\n        obj[key] = value\r\n    }\r\n}\r\n\r\n/**\r\n * Deserializes a json structure into an object graph.\r\n *\r\n * This process might be asynchronous (for example if there are references with an asynchronous\r\n * lookup function). The function returns an object (or array of objects), but the returned object\r\n * might be incomplete until the callback has fired as well (which might happen immediately)\r\n *\r\n * @param {object|array} schema to use for deserialization\r\n * @param {json} json data to deserialize\r\n * @param {function} callback node style callback that is invoked once the deserialization has\r\n *   finished. First argument is the optional error, second argument is the deserialized object\r\n *   (same as the return value)\r\n * @param {*} customArgs custom arguments that are available as `context.args` during the\r\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\r\n *   example, stores.\r\n * @returns {object|array} deserialized object, possibly incomplete.\r\n */\r\nexport default function deserialize(schema, json, callback, customArgs) {\r\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\r\n    schema = getDefaultModelSchema(schema)\r\n    invariant(isModelSchema(schema), \"first argument should be model schema\")\r\n    if (Array.isArray(json)) {\r\n        var items = []\r\n        parallel(\r\n            json,\r\n            function (childJson, itemDone) {\r\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\r\n                // instance is created synchronously so can be pushed\r\n                items.push(instance)\r\n            },\r\n            callback || GUARDED_NOOP\r\n        )\r\n        return items\r\n    } else\r\n        return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\r\n}\r\n\r\nexport function deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\r\n    if (json === null || json === undefined || typeof json !== \"object\")\r\n        return void callback(null, null)\r\n    var context = new Context(parentContext, modelSchema, json, callback, customArgs)\r\n    var target = modelSchema.factory(context)\r\n    // todo async invariant\r\n    invariant(!!target, \"No object returned from factory\")\r\n    // TODO: make invariant?            invariant(schema.extends ||\r\n    // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\r\n    // supertype, but modelschema did not provide extends clause\")\r\n    context.setTarget(target)\r\n    var lock = context.createCallback(GUARDED_NOOP)\r\n    deserializePropsWithSchema(context, modelSchema, json, target)\r\n    lock()\r\n    return target\r\n}\r\n\r\nexport function deserializePropsWithSchema(context, modelSchema, json, target) {\r\n    if (modelSchema.extends)\r\n        deserializePropsWithSchema(context, modelSchema.extends, json, target)\r\n\r\n    function deserializeProp(propDef, jsonValue, propName) {\r\n\r\n        function setValue(value) {\r\n            if (value !== SKIP) {\r\n                target[propName] = value\r\n            }\r\n        }\r\n\r\n        function preProcess(resultCallback) {\r\n            return function (err, newValue) {\r\n                function finalCallback(errPreliminary, finalOrRetryValue) {\r\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\r\n                        typeof propDef.afterDeserialize === \"function\") {\r\n\r\n                        propDef.deserializer(\r\n                            finalOrRetryValue,\r\n                            preProcess(resultCallback),\r\n                            context,\r\n                            target[propName]\r\n                        )\r\n                    } else {\r\n                        resultCallback(errPreliminary, finalOrRetryValue)\r\n                    }\r\n                }\r\n\r\n                onAfterDeserialize(finalCallback, err, newValue, jsonValue, json,\r\n                    propName, context, propDef)\r\n            }\r\n        }\r\n\r\n        propDef.deserializer(\r\n            jsonValue,\r\n            // for individual props, use root context based callbacks\r\n            // this allows props to complete after completing the object itself\r\n            // enabling reference resolving and such\r\n            preProcess(context.rootContext.createCallback(setValue)),\r\n            context,\r\n            target[propName] // initial value\r\n        )\r\n    }\r\n\r\n    Object.keys(modelSchema.props).forEach(function (propName) {\r\n        var propDef = modelSchema.props[propName]\r\n\r\n        function callbackDeserialize(err, jsonValue) {\r\n            if (!err && jsonValue !== undefined) {\r\n                deserializeProp(propDef, jsonValue, propName)\r\n            }\r\n        }\r\n\r\n        if (propName === \"*\") {\r\n            invariant(propDef === true, \"prop schema '*' can only be used with 'true'\")\r\n            deserializeStarProps(modelSchema, target, json)\r\n            return\r\n        }\r\n        if (propDef === true)\r\n            propDef = _defaultPrimitiveProp\r\n        if (propDef === false)\r\n            return\r\n        var jsonAttr = propDef.jsonname || propName\r\n        var jsonValue = json[jsonAttr]\r\n        onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef)\r\n    })\r\n}\r\n\r\n\r\nexport function onBeforeDeserialize(\r\n    callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\r\n\r\n    if (propDef && typeof propDef.beforeDeserialize === \"function\") {\r\n        propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context,\r\n            propDef)\r\n    } else {\r\n        callback(null, jsonValue)\r\n    }\r\n}\r\n\r\nexport function onAfterDeserialize(\r\n    callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\r\n\r\n    if (propDef && typeof propDef.afterDeserialize === \"function\") {\r\n        propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue,\r\n            propNameOrIndex, context, propDef)\r\n    } else {\r\n        callback(err, newValue)\r\n    }\r\n}\r\n\r\n","import {invariant, isModelSchema, processAdditionalPropArgs} from \"../utils/utils\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\nimport serialize from \"../core/serialize\"\r\nimport { deserializeObjectWithSchema } from \"../core/deserialize\"\r\n\r\n/**\r\n * `object` indicates that this property contains an object that needs to be (de)serialized\r\n * using its own model schema.\r\n *\r\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\r\n *\r\n * @example\r\n * class SubTask {}\r\n * class Todo {}\r\n *\r\n * createModelSchema(SubTask, {\r\n *     title: true,\r\n * });\r\n * createModelSchema(Todo, {\r\n *     title: true,\r\n *     subTask: object(SubTask),\r\n * });\r\n *\r\n * const todo = deserialize(Todo, {\r\n *     title: 'Task',\r\n *     subTask: {\r\n *         title: 'Sub task',\r\n *     },\r\n * });\r\n *\r\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function object(modelSchema, additionalArgs) {\r\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\r\n    var result = {\r\n        serializer: function (item) {\r\n            modelSchema = getDefaultModelSchema(modelSchema)\r\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\r\n            if (item === null || item === undefined)\r\n                return item\r\n            return serialize(modelSchema, item)\r\n        },\r\n        deserializer: function (childJson, done, context) {\r\n            modelSchema = getDefaultModelSchema(modelSchema)\r\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\r\n            if (childJson === null || childJson === undefined)\r\n                return void done(null, childJson)\r\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs)\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import {invariant, isModelSchema, getIdentifierProp, processAdditionalPropArgs} from \"../utils/utils\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\n\r\nfunction createDefaultRefLookup(modelSchema) {\r\n    return function resolve(uuid, cb, context) {\r\n        context.rootContext.await(modelSchema, uuid, cb)\r\n    }\r\n}\r\n\r\n/**\r\n * `reference` can be used to (de)serialize references that point to other models.\r\n *\r\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\r\n * or a string that represents which attribute in the target object represents the identifier of the object.\r\n *\r\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\r\n * an object. Its signature should be as follows:\r\n *\r\n * `lookupFunction(identifier, callback, context)` where:\r\n * 1. `identifier` is the identifier being resolved\r\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\r\n * 3. `context` see context.\r\n *\r\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\r\n *\r\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\r\n *\r\n * @example\r\n * class User {}\r\n * class Post {}\r\n *\r\n * createModelSchema(User, {\r\n *     uuid: identifier(),\r\n *     displayname: primitive(),\r\n * });\r\n *\r\n * createModelSchema(Post, {\r\n *     author: reference(User, findUserById),\r\n *     message: primitive(),\r\n * });\r\n *\r\n * function findUserById(uuid, callback) {\r\n *     fetch('http://host/user/' + uuid)\r\n *         .then(userData => {\r\n *             deserialize(User, userData, callback);\r\n *         })\r\n *         .catch(callback);\r\n * }\r\n *\r\n * deserialize(\r\n *     Post,\r\n *     {\r\n *         message: 'Hello World',\r\n *         author: 234,\r\n *     },\r\n *     (err, post) => {\r\n *         console.log(post);\r\n *     }\r\n * );\r\n *\r\n * @param target: ModelSchema or string\r\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function reference(target, lookupFn, additionalArgs) {\r\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\r\n    var initialized = false\r\n    var childIdentifierAttribute\r\n    if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\r\n        additionalArgs = lookupFn\r\n        lookupFn = undefined\r\n    }\r\n    function initialize() {\r\n        initialized = true\r\n        invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\")\r\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\")\r\n        if (typeof target === \"string\")\r\n            childIdentifierAttribute = target\r\n        else {\r\n            var modelSchema = getDefaultModelSchema(target)\r\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\r\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\r\n            childIdentifierAttribute = getIdentifierProp(modelSchema)\r\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\r\n        }\r\n    }\r\n    var result = {\r\n        serializer: function (item) {\r\n            if (!initialized)\r\n                initialize()\r\n            return item ? item[childIdentifierAttribute] : null\r\n        },\r\n        deserializer: function(identifierValue, done, context) {\r\n            if (!initialized)\r\n                initialize()\r\n            if (identifierValue === null || identifierValue === undefined)\r\n                done(null, identifierValue)\r\n            else\r\n                lookupFn(identifierValue, done, context)\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import { SKIP } from \"../constants\"\r\nimport {\r\n    invariant,\r\n    isPropSchema,\r\n    isAliasedPropSchema,\r\n    parallel,\r\n    processAdditionalPropArgs\r\n} from \"../utils/utils\"\r\nimport { onAfterDeserialize, onBeforeDeserialize } from \"../core/deserialize\"\r\nimport { _defaultPrimitiveProp } from \"../constants\"\r\n\r\n\r\n/**\r\n * List indicates that this property contains a list of things.\r\n * Accepts a sub model schema to serialize the contents\r\n *\r\n * @example\r\n * class SubTask {}\r\n * class Task {}\r\n * class Todo {}\r\n *\r\n * createModelSchema(SubTask, {\r\n *     title: true,\r\n * });\r\n * createModelSchema(Todo, {\r\n *     title: true,\r\n *     subTask: list(object(SubTask)),\r\n * });\r\n *\r\n * const todo = deserialize(Todo, {\r\n *     title: 'Task',\r\n *     subTask: [\r\n *         {\r\n *             title: 'Sub task 1',\r\n *         },\r\n *     ],\r\n * });\r\n *\r\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function list(propSchema, additionalArgs) {\r\n    propSchema = propSchema || _defaultPrimitiveProp\r\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\r\n    invariant(!isAliasedPropSchema(propSchema),\r\n        \"provided prop is aliased, please put aliases first\")\r\n    var result = {\r\n        serializer: function (ar) {\r\n            if (ar === undefined) {\r\n                return SKIP\r\n            }\r\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\r\n            return ar.map(propSchema.serializer)\r\n        },\r\n        deserializer: function (jsonArray, done, context) {\r\n            if (!Array.isArray(jsonArray))\r\n                return void done(\"[serializr] expected JSON array\")\r\n\r\n            function processItem(jsonValue, onItemDone, itemIndex) {\r\n                function callbackBefore(err, value) {\r\n                    if (!err) {\r\n                        propSchema.deserializer(value, deserializeDone, context)\r\n                    } else {\r\n                        onItemDone(err)\r\n                    }\r\n                }\r\n\r\n                function deserializeDone(err, value) {\r\n                    if (typeof propSchema.afterDeserialize === \"function\") {\r\n                        onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context,\r\n                            propSchema)\r\n                    } else {\r\n                        onItemDone(err, value)\r\n                    }\r\n                }\r\n\r\n                function callbackAfter(errPreliminary, finalOrRetryValue) {\r\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\r\n                        typeof propSchema.afterDeserialize === \"function\") {\r\n\r\n                        propSchema.deserializer(\r\n                            finalOrRetryValue,\r\n                            deserializeDone,\r\n                            context\r\n                        )\r\n                    } else {\r\n                        onItemDone(errPreliminary, finalOrRetryValue)\r\n                    }\r\n                }\r\n\r\n                onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context,\r\n                    propSchema)\r\n            }\r\n\r\n            parallel(\r\n                jsonArray,\r\n                processItem,\r\n                done\r\n            )\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","/**\r\n * Creates a model schema that (de)serializes from / to plain javascript objects.\r\n * Its factory method is: `() => ({})`\r\n *\r\n * @example\r\n * var todoSchema = createSimpleSchema({\r\n *     title: true,\r\n *     done: true,\r\n * });\r\n *\r\n * var json = serialize(todoSchema, { title: 'Test', done: false });\r\n * var todo = deserialize(todoSchema, json);\r\n *\r\n * @param {object} props property mapping,\r\n * @returns {object} model schema\r\n */\r\nexport default function createSimpleSchema(props) {\r\n    return {\r\n        factory: function() {\r\n            return {}\r\n        },\r\n        props: props\r\n    }\r\n}\r\n","/*\r\n * Deserialization\r\n */\r\nimport { invariant } from \"../utils/utils\"\r\nimport { getTargetContext } from \"./Context\"\r\n\r\n\r\n/**\r\n * Cancels an asynchronous deserialization or update operation for the specified target object.\r\n * @param instance object that was previously returned from deserialize or update method\r\n */\r\nexport default function cancelDeserialize(instance) {\r\n    invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\")\r\n    var context = getTargetContext(instance)\r\n    if (context) {\r\n        context.cancelAwaits()\r\n    }\r\n}\r\n","/*\r\n * Update\r\n */\r\n\r\nimport { invariant, isModelSchema, GUARDED_NOOP } from \"../utils/utils\"\r\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\r\nimport Context from \"./Context\"\r\nimport { deserializePropsWithSchema } from \"./deserialize\"\r\n\r\n/**\r\n * Similar to deserialize, but updates an existing object instance.\r\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\r\n * Further this method behaves similar to deserialize.\r\n *\r\n * @param {object} modelSchema, optional if it can be inferred from the instance type\r\n * @param {object} target target instance to update\r\n * @param {object} json the json to deserialize\r\n * @param {function} callback the callback to invoke once deserialization has completed.\r\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\r\n * @returns {object|array} deserialized object, possibly incomplete.\r\n */\r\nexport default function update(modelSchema, target, json, callback, customArgs) {\r\n    var inferModelSchema =\r\n        arguments.length === 2 // only target and json\r\n        || typeof arguments[2] === \"function\" // callback as third arg\r\n\r\n    if (inferModelSchema) {\r\n        target = arguments[0]\r\n        modelSchema = getDefaultModelSchema(target)\r\n        json = arguments[1]\r\n        callback = arguments[2]\r\n        customArgs = arguments[3]\r\n    } else {\r\n        modelSchema = getDefaultModelSchema(modelSchema)\r\n    }\r\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\r\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\r\n    var context = new Context(null, modelSchema, json, callback, customArgs)\r\n    context.setTarget(target)\r\n    var lock = context.createCallback(GUARDED_NOOP)\r\n    var result = deserializePropsWithSchema(context, modelSchema, json, target)\r\n    lock()\r\n    return result\r\n}\r\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\r\nimport { _defaultPrimitiveProp } from \"../constants\"\r\n\r\nfunction defaultRegisterFunction(id, value, context) {\r\n    context.rootContext.resolve(context.modelSchema, id, context.target)\r\n}\r\n\r\n/**\r\n *\r\n *\r\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\r\n * This is used by for example `reference()` to serialize the reference\r\n *\r\n * Identifier accepts an optional `registerFn` with the signature:\r\n * `(id, target, context) => void`\r\n * that can be used to register this object in some store. note that not all fields of this object might\r\n * have been deserialized yet.\r\n *\r\n * @example\r\n * var todos = {};\r\n *\r\n * var s = _.createSimpleSchema({\r\n *     id: _.identifier((id, object) => (todos[id] = object)),\r\n *     title: true,\r\n * });\r\n *\r\n * _.deserialize(s, {\r\n *     id: 1,\r\n *     title: 'test0',\r\n * });\r\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\r\n *\r\n * t.deepEqual(todos, {\r\n *     1: { id: 1, title: 'test1' },\r\n *     2: { id: 2, title: 'test2' },\r\n * });\r\n *\r\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\r\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n *\r\n * @returns {PropSchema}\r\n */\r\nexport default function identifier(arg1, arg2) {\r\n    var registerFn, additionalArgs\r\n    if (typeof arg1 === \"function\") {\r\n        registerFn = arg1\r\n        additionalArgs = arg2\r\n    } else {\r\n        additionalArgs = arg1\r\n    }\r\n    invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\")\r\n    var result = {\r\n        identifier: true,\r\n        serializer: _defaultPrimitiveProp.serializer,\r\n        deserializer: function (jsonValue, done, context) {\r\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\r\n                defaultRegisterFunction(id, context.target, context)\r\n                if (registerFn)\r\n                    registerFn(id, context.target, context)\r\n                done(err, id)\r\n            })\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\r\n\r\n/**\r\n * Similar to primitive, serializes instances of Date objects\r\n *\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function date(additionalArgs) {\r\n    // TODO: add format option?\r\n    var result = {\r\n        serializer: function(value) {\r\n            if (value === null || value === undefined)\r\n                return value\r\n            invariant(value instanceof Date, \"Expected Date object\")\r\n            return value.getTime()\r\n        },\r\n        deserializer: function (jsonValue, done) {\r\n            if (jsonValue === null || jsonValue === undefined)\r\n                return void done(null, jsonValue)\r\n            return void done(null, new Date(jsonValue))\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import { invariant, isPropSchema, isAliasedPropSchema, isIdentifierPropSchema } from \"../utils/utils\"\r\nimport { _defaultPrimitiveProp } from \"../constants\"\r\n\r\n/**\r\n * Alias indicates that this model property should be named differently in the generated json.\r\n * Alias should be the outermost propschema.\r\n *\r\n * @example\r\n * createModelSchema(Todo, {\r\n *     title: alias('task', primitive()),\r\n * });\r\n *\r\n * console.dir(serialize(new Todo('test')));\r\n * // { task : \"test\" }\r\n *\r\n * @param {string} name name of the json field to be used for this property\r\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\r\n * @returns {PropSchema}\r\n */\r\nexport default function alias(name, propSchema) {\r\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\r\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\r\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\r\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\r\n    return {\r\n        jsonname: name,\r\n        serializer: propSchema.serializer,\r\n        deserializer: propSchema.deserializer,\r\n        identifier: isIdentifierPropSchema(propSchema),\r\n        beforeDeserialize: propSchema.beforeDeserialize,\r\n        afterDeserialize: propSchema.afterDeserialize\r\n    }\r\n}\r\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\r\n\r\n/**\r\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\r\n\r\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\r\n\r\n * The `serializer` function has the signature:\r\n * `(value, key, obj) => void`\r\n\r\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\r\n\r\n * The `deserializer` function has the following signature for synchronous processing\r\n * `(value, context, oldValue) => void`\r\n\r\n * For asynchronous processing the function expects the following signature\r\n * `(value, context, oldValue, callback) => void`\r\n\r\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\r\n *\r\n * @example\r\n * var schemaDefault = _.createSimpleSchema({\r\n *     a: _.custom(\r\n *         function(v) {\r\n *             return v + 2;\r\n *         },\r\n *         function(v) {\r\n *             return v - 2;\r\n *         }\r\n *     ),\r\n * });\r\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\r\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\r\n *\r\n * var schemaWithAsyncProps = _.createSimpleSchema({\r\n *     a: _.customAsync(\r\n *         function(v) {\r\n *             return v + 2;\r\n *         },\r\n *         function(v, context, oldValue, callback) {\r\n *             somePromise(v, context, oldValue).then((result) => {\r\n *                 callback(null, result - 2)\r\n *             }.catch((err) => {\r\n *                 callback(err)\r\n *             }\r\n *         }\r\n *     ),\r\n * });\r\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\r\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\r\n *   t.deepEqual(res.a, 4)\r\n * };\r\n\r\n *\r\n * @param {function} serializer function that takes a model value and turns it into a json value\r\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function custom(serializer, deserializer, additionalArgs) {\r\n    invariant(typeof serializer === \"function\", \"first argument should be function\")\r\n    invariant((typeof deserializer === \"function\"), \"second argument should be a function or promise\")\r\n    var result = {\r\n        serializer: serializer,\r\n        deserializer: function (jsonValue, done, context, oldValue) {\r\n            if (deserializer.length === 4) {\r\n                deserializer(jsonValue, context, oldValue, done, additionalArgs)\r\n            } else {\r\n                done(null, deserializer(jsonValue, context, oldValue, null, additionalArgs))\r\n            }\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n","import {invariant, isAliasedPropSchema, isPropSchema, isMapLike, processAdditionalPropArgs} from \"../utils/utils\"\r\nimport {_defaultPrimitiveProp} from \"../constants\"\r\nimport list from \"./list\"\r\n\r\n/**\r\n * Similar to list, but map represents a string keyed dynamic collection.\r\n * This can be both plain objects (default) or ES6 Map like structures.\r\n * This will be inferred from the initial value of the targetted attribute.\r\n *\r\n * @param {*} propSchema\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function map(propSchema, additionalArgs) {\r\n    propSchema = propSchema || _defaultPrimitiveProp\r\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\r\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\r\n    var res = {\r\n        serializer: function (m) {\r\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\r\n            var isMap = isMapLike(m)\r\n            var result = {}\r\n            if (isMap)\r\n                m.forEach(function (value, key) {\r\n                    result[key] = propSchema.serializer(value)\r\n                })\r\n            else for (var key in m)\r\n                result[key] = propSchema.serializer(m[key])\r\n            return result\r\n        },\r\n        deserializer: function (jsonObject, done, context, oldValue) {\r\n            if (!jsonObject || typeof jsonObject !== \"object\")\r\n                return void done(\"[serializr] expected JSON object\")\r\n            var keys = Object.keys(jsonObject)\r\n            list(propSchema, additionalArgs).deserializer(\r\n                keys.map(function (key) {\r\n                    return jsonObject[key]\r\n                }),\r\n                function (err, values) {\r\n                    if (err)\r\n                        return void done(err)\r\n                    var isMap = isMapLike(oldValue)\r\n                    var newValue\r\n                    if (isMap) {\r\n                        // if the oldValue is a map, we recycle it\r\n                        // there are many variations and this way we don't have to\r\n                        // know about the original constructor\r\n                        oldValue.clear()\r\n                        newValue = oldValue\r\n                    } else\r\n                        newValue = {}\r\n                    for (var i = 0, l = keys.length; i < l; i++)\r\n                        if (isMap)\r\n                            newValue.set(keys[i], values[i])\r\n                        else\r\n                            newValue[keys[i]] = values[i]\r\n                    done(null, newValue)\r\n                },\r\n                context\r\n            )\r\n        }\r\n    }\r\n    res = processAdditionalPropArgs(res, additionalArgs)\r\n    return res\r\n}\r\n","import { invariant, isPropSchema, isMapLike, processAdditionalPropArgs } from \"../utils/utils\"\r\nimport { _defaultPrimitiveProp } from \"../constants\"\r\nimport list from \"./list\"\r\n\r\n/**\r\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\r\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\r\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\r\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\r\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\r\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\r\n * compact.\r\n *\r\n * @param {any} propSchema\r\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {PropSchema}\r\n */\r\nexport default function mapAsArray(propSchema, keyPropertyName, additionalArgs) {\r\n    propSchema = propSchema || _defaultPrimitiveProp\r\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\r\n    invariant(!!keyPropertyName, \"expected key property name as second argument\")\r\n    var res = {\r\n        serializer: function (m) {\r\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\r\n            var isMap = isMapLike(m)\r\n            var result = []\r\n            // eslint-disable-next-line no-unused-vars\r\n            if (isMap) {\r\n                m.forEach(function (value) {\r\n                    result.push(propSchema.serializer(value))\r\n                })\r\n            } else for (var key in m) {\r\n                result.push(propSchema.serializer(m[key]))\r\n                // result[key] = propSchema.serializer(m[key])\r\n            }\r\n            return result\r\n        },\r\n        deserializer: function (jsonArray, done, context, oldValue) {\r\n            list(propSchema, additionalArgs).deserializer(\r\n                jsonArray,\r\n                function (err, values) {\r\n                    if (err)\r\n                        return void done(err)\r\n                    var isMap = isMapLike(oldValue)\r\n                    var newValue\r\n                    if (isMap) {\r\n                        oldValue.clear()\r\n                        newValue = oldValue\r\n                    } else {\r\n                        newValue = {}\r\n                    }\r\n                    for (var i = 0, l = jsonArray.length; i < l; i++)\r\n                        if (isMap)\r\n                            newValue.set(values[i][keyPropertyName], values[i])\r\n                        else\r\n                            newValue[values[i][keyPropertyName].toString()] = values[i]\r\n                    done(null, newValue)\r\n                },\r\n                context\r\n            )\r\n        }\r\n    }\r\n    res = processAdditionalPropArgs(res, additionalArgs)\r\n    return res\r\n}\r\n","import {processAdditionalPropArgs} from \"../utils/utils\"\r\n\r\n/**\r\n * Indicates that this field is only need to putted in the serialized json or\r\n * deserialized instance, without any transformations. Stay with its original value\r\n *\r\n * @example\r\n * createModelSchema(Model, {\r\n *     rawData: raw(),\r\n * });\r\n *\r\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\r\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\r\n *\r\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\r\n * @returns {ModelSchema}\r\n */\r\nexport default function raw(additionalArgs) {\r\n    var result = {\r\n        serializer: function (value) {\r\n            return value\r\n        },\r\n        deserializer: function (jsonValue, done) {\r\n            return void done(null, jsonValue)\r\n        }\r\n    }\r\n    result = processAdditionalPropArgs(result, additionalArgs)\r\n    return result\r\n}\r\n"],"names":["formatters","j","v","JSON","stringify","error","message","invariant","condition","variables","Array","prototype","slice","call","arguments","variablesToLog","index","formattedMessage","replace","match","format","formatter","variable","push","console","length","log","apply","Error","GUARDED_NOOP","err","parallel","ar","processor","cb","left","filter","resultArray","failed","forEach","value","idx","result","bind","isPrimitive","isModelSchema","thing","factory","props","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isIdentifierPropSchema","identifier","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","processAdditionalPropArgs","additionalArgs","argName","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","modelSchema","createModelSchema","Object","model","targetClass","s","primitive","jsonValue","done","SKIP","Symbol","_defaultPrimitiveProp","STRIP_COMMENTS","ARGUMENT_NAMES","serializableDecorator","target","propName","descriptor","fnStr","undefined","paramNames","toString","indexOf","paramNumber","context","params","i","key","prop","json","Function","concat","info","hasOwnProperty","get","set","writable","serialize","arg1","arg2","schema","isArray","map","item","serializeWithSchema","obj","res","propDef","serializeStarProps","rootContextCache","WeakMap","Context","parentContext","onReadyCb","customArgs","this","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","schemaHasAlias","name","deserializeObjectWithSchema","callback","setTarget","lock","createCallback","deserializePropsWithSchema","deserializeStarProps","jsonAttr","onBeforeDeserialize","preProcess","resultCallback","newValue","onAfterDeserialize","errPreliminary","finalOrRetryValue","afterDeserialize","deserializeProp","jsonParentValue","propNameOrIndex","beforeDeserialize","object","childJson","reference","lookupFn","childIdentifierAttribute","initialized","initialize","uuid","await","createDefaultRefLookup","getIdentifierProp","identifierValue","list","jsonArray","onItemDone","itemIndex","deserializeDone","callbackAfter","fn","fired","once","delete","join","resolved","resolve","opts","splice","cancelAwaits","self","refOpts","arg3","instance","items","itemDone","registerFn","id","defaultRegisterFunction","Date","getTime","oldValue","m","isMap","jsonObject","values","l","keyPropertyName"],"mappings":"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"}